// SPDX-License-Identifier: MIT
pragma ton-solidity >= 0.62.0;
pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

import "./interfaces/INonce.tsol";
import "./interfaces/ITranslator.tsol";
import "./interfaces/IClientReceiverContract.tsol";
import "./interfaces/IInitializerSender.tsol";
import "./interfaces/IInitializerReceiver.tsol";
import "./base/AsterizmStructs.tsol";
import "./libs/Ownable.tsol";
import "./base/AsterizmErrors.tsol";
import "./base/AsterizmTransferFlags.tsol";
import "./base/AsterizmEnvs.tsol";

contract AsterizmInitializer is Ownable, IInitializerSender, IInitializerReceiver, AsterizmStructs {

    /// Set translator event
    /// @param _translatorAddress address
    event SetTranslatorEvent(address _translatorAddress);

    /// Set outbound nonce event
    /// @param _nonceAddress address
    event SetOutBoundNonceEvent(address _nonceAddress);

    /// Set inbound nonce event
    /// @param _nonceAddress address
    event SetInBoundNonceEvent(address _nonceAddress);

    /// Set decryption send availeble event
    /// @param _flag bool
    event SetDecriptionSendAvailableEvent(bool _flag);

    /// Set encryption send availeble event
    /// @param _flag bool
    event SetEncriptionSendAvailableEvent(bool _flag);

    /// Block address event
    /// @param _address address
    event AddBlockAddressEvent(address _address);

    /// Remove block address event
    /// @param _address address
    event RemoveBlockAddressEvent(address _address);

    /// Payload error event
    /// Client can listen it for moniroting error transfers
    /// @param _srcChainId uint64  Source chain ID
    /// @param _srcAddress address  Source address
    /// @param _dstChainId uint64  Destination chain ID
    /// @param _dstAddress address  Destination address
    /// @param _nonce uint  Nonce
    /// @param _transferHash bytes32  Tansfer hash
    /// @param _payload bytes  Payload
    /// @param _reason bytes  Error reason
    event PayloadErrorEvent(uint64 _srcChainId, address _srcAddress, uint64 _dstChainId, address _dstAddress, uint _nonce, bytes32 _transferHash, TvmCell _payload, TvmCell _reason);

    /// Sent payload event
    /// @param _transferHash bytes32  Transfer hash
    event SentPayloadEvent(bytes32 _transferHash);

    INonce private inboundNonce;
    INonce private outboundNonce;
    ITranslator private translatorLib;
    uint64 private localChainId;
    mapping(address => bool) public blockAddresses;
    mapping(bytes32 => bool) private outgoingTransfers;

    constructor (ITranslator _translatorLibrary) public {
        tvm.accept();

        setTransalor(_translatorLibrary);
        uint128 chainValue = address(this).balance - AsterizmEnvs.INITIALIZER__MIN_CONTRACT_BALANCE;
        localChainId = translatorLib.getLocalChainId{value: chainValue >= AsterizmEnvs.INITIALIZER__MIN_CONTRACT_BALANCE ? chainValue : AsterizmEnvs.INITIALIZER__MIN_CONTRACT_BALANCE}().await;
        
        tvm.rawReserve(AsterizmEnvs.TRANSLATOR__MIN_CONTRACT_BALANCE, 0);
        msg.sender.transfer({
            value: 0,
            flag: 128,
            bounce: false
        });
    }

    /// Only translator modifier
    modifier onlyTranslator() {
        require(msg.sender == address(translatorLib), AsterizmErrors.INITIALIZER__ONLY_TRANSLATOR__ERROR);
        _;
    }

    /** Internal logic */

    /// Set translator
    /// @param _translatorLib ITranslator  Translator library
    function setTransalor(ITranslator _translatorLib) public onlyOwner {
        translatorLib = _translatorLib;
        emit SetTranslatorEvent(address(_translatorLib));
    }

    /// Set outbound nonce
    /// @param _nonce INonce  Set outbound nonce
    function setOutBoundNonce(INonce _nonce) public onlyOwner {
        outboundNonce = _nonce;
        emit SetOutBoundNonceEvent(address(_nonce));
    }

    /// Set inbound nonce
    /// @param _nonce INonce  Set inbound nonce
    function setInBoundNonce(INonce _nonce) public onlyOwner {
        inboundNonce = _nonce;
        emit SetInBoundNonceEvent(address(_nonce));
    }

    /// Block address
    /// @param _address address  Available flag
    function addBlockAddress(address _address) external onlyOwner {
        blockAddresses[_address] = true;
        emit AddBlockAddressEvent(_address);
    }

    /// Unblock address
    /// @param _address address  Available flag
    function removeBlockAddress(address _address) external onlyOwner {
        delete blockAddresses[_address];
        emit RemoveBlockAddressEvent(_address);
    }

    /** External logic */

    /// Validate income transfer by hash
    /// @param _transferHash bytes32
    function validIncomeTransferHash(bytes32 _transferHash) external internalMsg view override returns(bool) {
        return outgoingTransfers[_transferHash];
    }

    /// Return local chain id
    /// @return uint64
    function getLocalChainId() external internalMsg view responsible override returns(uint64) {
        uint128 balance = address(this).balance - msg.value;
        tvm.rawReserve(balance >= AsterizmEnvs.INITIALIZER__MIN_CONTRACT_BALANCE ? balance : AsterizmEnvs.INITIALIZER__MIN_CONTRACT_BALANCE, 0);
        return { value: 0, flag: AsterizmTransferFlags.ALL_NOT_RESERVED, bounce: false } localChainId;
    }

    /// Initiate asterizm transfer
    /// Only clients can call this method
    /// @param _dto IzIninTransferRequestDto  Method DTO
    function initTransfer(IzIninTransferRequestDto _dto) external override {
        require(!blockAddresses[msg.sender], AsterizmErrors.INITIALIZER__SENDER_ADDRESS_IS_BLOCKED__ERROR);
        require(!blockAddresses[_dto.dstAddress], AsterizmErrors.INITIALIZER__TARGET_ADDRESS_IS_BLOCKED__ERROR);

        TrSendMessageRequestDto dto = _buildTrSendMessageRequestDto(
            msg.sender, _dto.dstChainId, _dto.dstAddress,
            //TODO: допилить нонсы
            // _dto.useForceOrder ? outboundNonce.increaseNonce(_dto.dstChainId, abi.encodePacked(msg.sender, _dto.dstAddress)) : 0,
            0,
            _dto.useForceOrder, _dto.txId, _dto.transferHash, _dto.payload
        );
        translatorLib.sendMessage{value: msg.value}(dto);
    }

    /// Receive payload from translator
    /// @param _dto IzReceivePayloadRequestDto  Method DTO
    function receivePayload(IzReceivePayloadRequestDto _dto) external override onlyTranslator {
        require(!blockAddresses[_dto.dstAddress], AsterizmErrors.INITIALIZER__TARGET_ADDRESS_IS_BLOCKED__ERROR);
        if (_dto.forceOrder) {
            //TODO: допилить нонсы
        }

        require(_dto.dstAddress != address(this) && _dto.dstAddress != msg.sender, AsterizmErrors.INITIALIZER__WRONG_DESTINATION_ADDRESS__ERROR);

        ClAsterizmReceiveRequestDto dto = _buildClAsterizmReceiveRequestDto(
            _dto.srcChainId, _dto.srcAddress, _dto.dstChainId,
            _dto.dstAddress, _dto.nonce, _dto.txId, _dto.transferHash, _dto.payload
        );

        IClientReceiverContract(_dto.dstAddress).asterizmIzReceive{value: uint128(_dto.gasLimit)}(dto);

        outgoingTransfers[_dto.transferHash] = true;
        emit SentPayloadEvent(_dto.transferHash);
    }
}
